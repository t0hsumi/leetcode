# step 1
```python3
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head

        while node is not None:
            next_node = node.next
            while next_node is not None and node.val == next_node.val:
                next_node = next_node.next

            node.next = next_node
            node = node.next

        return head
```

singly linked-listの問題は基本的には、
```python3
while node is not None：
    # なんかする
    node = node.next
```
となっていて、「なんかする」部分だけやることの言語化をサボらなければ解けそう。
Arial 60はデータ構造別、アルゴリズム別で大別されているので、最初の数問やれば、同じデータ構造やらアルゴリズムやらの後半問題は割とすんなり解ける気がする。

nをノードの数として、
- time complexity: O(n)
- space complexity: O(n) (Auxiliary space: O(1))

# step 2
参考
- https://github.com/katataku/leetcode/pull/2
- https://github.com/ichika0615/arai60/pull/3
- https://github.com/tarinaihitori/leetcode/pull/3

step 1で書いたものと同じ解法だが、`next_node`を定義せず、そのまま`node.next`を書き換えるものがあった。
step 1中で書いた構造の通り書きたい気持ちがあり、`node.next`の値がチラチラ変わるのは、読んでいて疲れそうだったので、`next_node`を定義してしまった方が読みやすいように思った。

また、次の値のノードに至るまでを関数化するものもあったが、このサイズのコードならそれをする必要はないように感じた。切り分けた処理を他で利用することも想定できなかった。

他の解法としてはには再帰を用いるもの、出現した値を全て保存しておき、それを用いて新たにLinked-listを作るものがあった。

再帰を使った解法
```python3
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return None
        
        next_node = self.deleteDuplicates(head.next)
        if next_node is not None and head.val == next_node.val:
            return next_node
        else:
            head.next = next_node
            return head
```

再帰なし
```python3
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head

        while node is not None:
            next_node = node.next
            while next_node is not None and node.val == next_node.val:
                next_node = next_node.next
            node.next = next_node
            node = node.next
        
        return head
```

# step 3
再帰なし
```python3
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head

        while node is not None:
            next_node = node.next
            while next_node is not None and node.val == next_node.val:
                next_node = next_node.next
            node.next = next_node
            node = node.next
        
        return head
```

再帰あり
```python3
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return None
        
        next_node = self.deleteDuplicates(head.next)
        if next_node is not None and head.val == next_node.val:
            return next_node
        else:
            head.next = next_node
            return head
```