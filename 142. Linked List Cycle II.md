# step 1

setを使った解法

[141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/)
を解いていたので、返り値を変更するだけだった。

nをノードの数として、
- time complexity: O(n)
- space complexity: O(n)
```python3
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        visited = set()
        node = head

        while node is not None:
            if node in visited:
                return node
            
            visited.add(node)
            node = node.next
        
        return None
```

---

tortise and hare

`detectCycle()`と`computeCycleStartingNode()`は別の処理としてかけるので分けた。
`getCycleStartingNode()`にすると、O(1)の処理を予想する場合がありそうだったので、`computeCycleStartingNode()`とした。

改善点
- `computeCycleStartingNode()`のtype hintを入れていなかった。
- コメント：知っていれば当たり前かもしれないが、（このアルゴリズムを見る前の自分のように）知らない人からすると、何をしているのかよくわからないように思う。


nをノードの数として
- time complexity: O(n)
- space complexity: O(n)
- Auxiliary space: O(1)
```python3
class Solution:
    def computeCycleStartingNode(self, head, nodeInCycle):
        node = head
        
        while node != nodeInCycle:
            node = node.next
            nodeInCycle = nodeInCycle.next
        
        return node

    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast = head
        slow = head

        while fast is not None and fast.next is not None:
            fast = fast.next.next
            slow = slow.next

            if fast == slow:
                return self.computeCycleStartingNode(head, slow)
        
        return None
```

# step 2
参考
- https://github.com/katataku/leetcode/pull/5/files
- https://github.com/konnysh/arai60/pull/2/files
- https://github.com/ichika0615/arai60/pull/2/files
- https://github.com/h1rosaka/arai60/pull/4/files
- https://discord.com/channels/1084280443945353267/1221030192609493053/1225674901445283860

discordを見ながらコード構造別で書いていく

1.関数化
```python3
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def findCycleStartingNode(head, nodeInCycle):
            node = head
            while node != nodeInCycle:
                node = node.next
                nodeInCycle = nodeInCycle.next
            return node

        fast = head
        slow = head

        while fast is not None and fast.next is not None:
            fast = fast.next.next
            slow = slow.next
            
            if fast == slow:
                return findCycleStartingNode(head, slow)
        
        return None
```

2.python独自の記法
```python3
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast = head
        slow = head

        while fast is not None and fast.next is not None:
            fast = fast.next.next
            slow = slow.next
            
            if fast == slow:
                break
        else:
            return None

        node = head
        while node != slow:
            node = node.next
            slow = slow.next
        return node
```

3.無限ループ
```python3
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast = head
        slow = head

        while True:
            if fast is None or fast.next is None:
                return None
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                break
        
        node = head
        while node != slow:
            node = node.next
            slow = slow.next
        return node
```

4.関数化2
```python3
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def findCollision(head):
            fast = head
            slow = head

            while fast is not None and fast.next is not None:
                fast = fast.next.next
                slow = slow.next
                if fast == slow:
                    return fast
            return None
        
        nodeInCycle = findCollision(head)
        if nodeInCycle is None:
            return None

        node = head
        while node != nodeInCycle:
            node = node.next
            nodeInCycle = nodeInCycle.next
        return node
```

1, 4の関数化が今回は好み。抽出した処理にしっかり名前がつくからだと思う。

主な変更点
- inner functionを使用するようにした。4の関数化についてはprivate functionにしても良いが、
1の関数化に関しては他の関数で呼び出す見込みがなさそうに感じた。
- 関数名を`compute*`から`find*`に変更。

# step 3
```python3
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        visited = set()
        node = head

        while node is not None:
            if node in visited:
                return node
            visited.add(node)
            node = node.next
        return None
```
```python3
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """Return the node where the cycle (if any) begins.

        If there is no cycle, return None.
        This function uses Floyd's cycle-finding algorithm.
        """
        def findNodeInCycle(head):
            """
            Return the node in the cycle if any. This node isn't necessarily
            the node where the cycle begins.
            If there is no cycle, return None.

            Argument:
                head -- the linked-list head
            """
            fast = head
            slow = head
            while fast is not None and fast.next is not None:
                fast = fast.next.next
                slow = slow.next
                if fast == slow:
                    return slow
            return None
        
        nodeInCycle = findNodeInCycle(head)
        if nodeInCycle is None:
            return None
        node = head
        while node != nodeInCycle:
            node = node.next
            nodeInCycle = nodeInCycle.next
        return node
```

# step 4
コメントまとめ
- 変数名は`lower_with_under`というガイドラインがある。
- 意味的に異なる内容で同じ変数を使い回している。（step 2のpython独自の記法のところ）

その他
- docstringに実装の詳細を書いていたが、別でコメントを入れた方が良いかも
(https://google.github.io/styleguide/pyguide.html#383-functions-and-methods)
    > The docstring should describe the function’s calling syntax and its semantics, but generally not its implementation details, unless those details are relevant to how the function is to be used.

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        visited = set()
        while node is not None:
            if node in visited:
                return node
            visited.add(node)
            node = node.next
        return None
```

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def find_cycle(head):
            slow = head
            fast = head
            while fast is not None and fast.next is not None:
                fast = fast.next.next
                slow = slow.next
                if fast == slow:
                    return fast
            return None

        def find_cycle_starting_node(head, node_in_cycle):
            node = head
            while True:
                if node == node_in_cycle:
                    return node
                node = node.next
                node_in_cycle = node_in_cycle.next
        
        node_in_cycle = find_cycle(head)
        if node_in_cycle is None:
            return None
        return find_cycle_starting_node(head, node_in_cycle)
```